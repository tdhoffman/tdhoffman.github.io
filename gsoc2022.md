---
layout: default
---

### Ongoing Links
- [`pysal_base`](https://github.com/tdhoffman/pysal-base), a repository of draft base classes for PySAL.
- [`tdhoffman/spreg`](https://github.com/tdhoffman/spreg), my forked copy of `spreg`. This is a testing ground for the `spreg` formula dispatcher and new model APIs.
- [`tdhoffman/esda`](https://github.com/tdhoffman/esda), my forked copy of `esda`. This is a testing ground for base classes in descriptive or unsupervised settings.

## 3. Convergence
*Posted 7 July 2022*

While conceptualizing this project, the twin streams of formula implementation and library standardization seemed quite separate to me. Naturally, a solid base class spec would lead to easier implementations of formulas, but I didn't see them as being much more related than that. This week, however, the commonalities between these two objectives merged.

First, I began designing a generic base class for PySAL models. I based my design off of the novel framework developed in Guo et al. (2022), which unifies a variety of spatial models under one paradigm (see Table 1 and Figure 1 for more information). The structure is: data, model, objective function, optimization method, and output. Such a structure broadly characterizes nearly every model in PySAL, and would offer a sleek way to standardize the user-facing model classes. Drafts of this idea can be found in my [`pysal_base`](https://github.com/tdhoffman/pysal-base) repository; in the coming weeks I will be building on these ideas to create minimal working examples to showcase to the PySAL developers at large.

In parallel, I created a demo of the `formulaic` library (called `formula_test.py`) in my forked copy of `spreg` for implementing spatial lag of X models. This demo showcases how to create a model matrix for spatially lagged covariates using native features of the `formulaic` library. All that remains to implement spatial lag and spatial error models is to add preprocessing of formula strings that recognizes when the dependent variable is being lagged and when a spatial error term is being added. These will be implemented for next week.

Together, these two streams are starting to converge to form a proposal for PySAL's next-gen model API. Ideally, I'll equip `spreg` with a `from_formula` function that generates and runs models similar to R's `lm` function simply given a formula and a dataframe. This external-facing method will connect nicely to updated versions of the modeling classes, which will conform to the new base template.

**References**

Guo, H., Python, A., and Liu, Y. (2022) "A generalized regionalization framework for geographical modelling and its application in spatial regression." [arXiv:2206.09429](https://arxiv.org/abs/2206.09429).

## 2. Base Class Rethinking
*Posted 1 July 2022*

This week, I accomplished my two goals of implementing `scikit-learn`-compatible versions of [`Moran_Local`](https://github.com/tdhoffman/esda/blob/master/esda/sklearn_moran.py) and [`GM_Lag`](https://github.com/tdhoffman/spreg/blob/master/spreg/sklearn_twosls_sp.py) and starting discussions about converting PySAL's style. In doing this, I got a better picture of the potential advantages and disadvantages of the paradigm.

One issue I ran into while building out the demo classes was the location of the spatial weights matrix in a `scikit-learn` style estimator. Putting the matrix in the `__init__` method of a class implies that the matrix is a parameter rather than data, whereas putting the matrix in the `fit` method of a class implies that it is data rather than a parameter. Each choice has implications on the format and usage of the class. Personally, I prefer placing the spatial weights matrix in the `__init__` method as that choice encourages users to tune hyperparameters of the estimator for each spatial domain they are handling. However, this could lead to memory issues if users need to analyze many spatial domains. This dilemma was also noticed by Martin Fleischmann in the `esda` issue thread.

In `spreg`, Eli Knaap and Luc Anselin discussed how PySAL and `scikit-learn` have generally different objectives in their modeling frameworks: the former is typically focused on inference and interpretation, while the latter is centered around prediction. These different use cases affect the design patterns of the two libraries, and as a result it may not make sense to mimic the design pattern from `scikit-learn`. Of course, Wilkinson formulas were viewed as being useful to users on this thread as they reflect how social scientists think about models, thus making the library more accessible to a wider base of users. 

For these reasons, I think it may be more useful to design a set of PySAL-specific base classes. While `scikit-learn` and multiple dispatch might not be great fits for the library, it still needs consistent standards (whether or not they conform to external rules). Creating a PySAL-specific framework would have several key advantages, like in-house maintainability and customizability. This week, my goals are to begin prototyping Wilkinson formulas (as they are universally popular) and to think of design constraints for a set of PySAL-specific base classes.
    
## 1. Initial Goals
*Posted 26 June 2022*

At our first meeting, my mentors and I discussed the options we have for implementing new interfaces to PySAL's model and exploratory statistic classes. We discussed using multiple dispatch or ducktyping from `scikit-learn` and chose to begin with ducktyping `scikit-learn` as multiple dispatch has been deemed non-Pythonic. While developing functionality for Wilkinson formulas is an ancillary goal of this project, we are keeping it in mind as we make interface edits as those structural changes affect the formula implementation.

My first two goals are as follows:
1. Choose an unsupervised statistic (`Moran_Local`) and a supervised statistic (`GM_Lag`) and implement them using the `scikit-learn` paradigm. This will give us two concrete, minimal working examples that we can share to package leads.
2. Start issues in relevant packages to fill out the cells in the table below. We want to know what must be done for each package to switch to a `scikit-learn` interface and to extend it to Wilkinson formulas.

| Package | Requirements for ducktyping `scikit-learn` | Requirements for extending to Wilkinson formulas |
| :-----: | ------------------------------------------ | ------------------------------------------------ |
| `spreg` | | |
| `gwr`   | | |
| `esda`  | | |
| `spopt` | | |
|`weights`| | |
| `spglm` | | |
| ...     | | |

Finally, we aim to include automatic attribution tools to all the new interfaces so that users may easily generate the proper citations for the code they are using.
